# 对象池/内存分配器
无论是对象池还是内存分配器，核心都是如何维护空闲内存块。
## 概述
设计对象池/内存分配器的时候可以从以下两个角度考虑。
> 维护的方式
维护的方式通常可以采用以下数据结构：
- 链表
- 多级链表
- 哈希表
> 数据结构的内存在哪？
建立这些数据结构需要内存，可以采用以下3种方式维护：
1. 指针存在空闲块的最开头，分配给用户的内存同样包含指针。这种方式最节省内存，但是要注意，只能对空闲块这样做。如果分配出去之后再读这个指针那就有问题了。
2. 指针存在空闲块的开头/结尾，但是分配给用户的内存剔除Header/Footer。
3. 额外内存方式实现起来相对简单，在内存池之外额外维护数据结构，但是也最浪费内存。

## 对象池
对象池每次分配与释放的内存块大小都是固定的。参考答案里采用法1)维护一个空闲块链表。类似Linux里slub的实现，不过slub要复杂的多。要考虑抢占，多核，NUMA等问题。

## 内存分配器
内存分配器相比对象池困难的一点在于要支持不同len的内存分配/释放请求，通常要考虑如何分裂/合并空闲块。
- 内存分配器一个最直接的实现方法就是借助对象池实现。比如提前定义若干不同大小的对象池。给定一个要分配的内存len，从>=len的第一个对象池找，一直找到最大的对象池，找到了之后直接返回，不涉及内存块的分裂与合并。这样做的缺点就是会有内碎片。Linux中的kmalloc就是这么实现的。
- 另一种实现方法可以采用双向链表把所有空闲块串起来，由于在释放的时候需要和相邻的左右空闲块合并，所以要采用Header/Footer的方式维护数据结构。比如CSAPP中的显式空闲链表就是这么做的。
- 还有一种实现方式是采用多级链表，也就是每个len区间维护一个双向链表。双向链表的指针同样使用Header/Footer的方式存储。分离空闲链表采用的是这种方法。
- 还有一种实现方式也是用多级链表，如果每个内存块都是4K为粒度的，那么可以用一个翻转bit的trick得到左右邻居，就不需要Header/Footer了。Linux中的Buddy System是这么做的。缺点就是要求以4K为粒度分配。
- 最后还有一种方式，前面几种方式分配的时候都需要遍历链表（除了第一个），如果用平衡树记录空闲区间，可以在log(N)的时间里找到best bit的空闲块。但是这种方式就不太好把数据结构存在内存池里了，可以用额外空间记录这些metadata。